---
layout: post
title:  "Tasty Korma Recipies"
date:   2014-09-20 16:00:00
categories: korma clojure sql
---
# Tasty Korma Recipes

[Korma](http://sqlkorma.com/) is a handy library that provides an ORM-like abstraction layer for SQL in Clojure.  The [docs](http://sqlkorma.com/docs) are good, but sometimes an example is more useful.  Here are some handy things you can do (I've used MySQL but the techniques, like Korma, can be used with any relational database):

## Prepare/Transform

Korma can automatically process data going in (via INSERT and UPDATE) and out (via SELECT) of the database, which you can use to make your life easier in the world of Clojure.

### Converting Timestamps

I like to use the most appropriate datatypes in my schemas, but often I want to use UNIX time in Clojure for working with timestamps:

{% highlight clojure %}

(ns conan.is
  (:import java.sql.Timestamp)
  (:require [clj-time.coerce :refer [from-long to-long]]
            [clj-time.format :refer [formatter parse unparse]]
            [korma.core :refer :all]
            [korma.db :refer :all]))

;; db connection defined here 

(def timestamp-formatter (formatter "yyyy-MM-dd HH:mm:ss"))

(defentity goals
  (prepare (fn [{timestamp :timestamp :as v}]
             (if timestamp
               (assoc v :timestamp (unparse timestamp-formatter (from-long timestamp)))
               v)))
  (transform (fn [{timestamp :timestamp :as v}]
               (if timestamp
                 (assoc v :timestamp (.getTime timestamp))
                 v))))

{% endhighlight %}

We define a formatter in the style of MySQL timestamps.  When we insert a row, we send the timestamp column as a long, in milliseconds since the epoch.  The `prepare` function turns the long into a [clj-time](https://github.com/clj-time/clj-time) `DateTime`, and then unparses that into a string using the formatter.  When selecting data, the `transform` function just calls the `getTime()` method of the `java.sql.Timestamp` that we get back from JDBC.  In Clojure we only ever have to work with milliseconds since the epoch, and in the database we can use the native datatypes.

### Avoiding Underscores

Here's a pet hate of mine: MySQL doesn't allow hyphens in table or column names, but in Clojure the convention is always to use hyphens in symbols.  Using `prepare` and `transform`, we can reconcile this.  Let's make a table with underscores:

{% highlight sql %}

CREATE TABLE my_table (
  my_column INT
);

{% endhighlight %}

We can define an entity that will use hyphens instead of underscores:

{% highlight clojure %}

(defentity my-table 
  (table :my_table) 
  (prepare (fn [{:as v}] (rename-keys v {:my-column :my_column})))
  (transform (fn [{:as v}] (debug "v:" v) (rename-keys v {:my_column :my-column}))))

{% endhighlight %}

Here we're simply renaming a specific column in the data map on the way in and out here.  We can generalise this to replace hyphens in all column names:

{% highlight clojure %}

(defentity my-table
  (table :my_table)
  (prepare
    (fn [{:as v}]
      (rename-keys v
                   (reduce
                     #(assoc %1 (first %2) (keyword (replace (name (first %2)) #"-" "_")))
                     {} v))))
  (transform
    (fn [{:as v}]
      (rename-keys v
                   (reduce
                     #(assoc %1 (first %2) (keyword (replace (name (first %2)) #"_" "-")))
                     {} v)))))

{% endhighlight %}

Here we're taking the data map and running [`clojure.set/rename-keys`](http://clojuredocs.org/clojure_core/clojure.set/rename-keys) over it, passing in a map that we've created by using [`clojure.string/replace`](http://clojuredocs.org/clojure_core/clojure.string/replace) to generate a map describing how to replace underscores with hyphens.  Note that it's the opposite way round on the way out than on the way in.  Now we can avoid using underscores in the entity and column names everywhere!